"""
Alice and Bob communicate a secret key via a quantum communication channel ( such as a 
fiber optic cable which uses the polarization of a photon to represent the state of a qubit ). 
This secret key will then be useful to allow them to communicate via a classical communication
channel using symmetric key cryptography. They'll also be notified incase an intruder tries to 
intercept the key.
"""

from qiskit import QuantumCircuit, Aer, assemble
from numpy.random import randint
import random

intrusion = input("Intrusion? (True / False) \n")
if intrusion == "True":
    intrusion = True
else:
    intrusion = False

# Qiskit measures in Z-basis by default

# function to measure in the X-basis
def x_measurement(qc, qubit, cbit):
    # Measure the "qubit" in X-basis and store the result in "cbit"
    # convert [|+> or |->] to [|0> or |1>] OR vice-versa
    qc.h(qubit)
    # measure this qubit in Z-basis
    qc.measure(qubit, cbit)
    # return the modified circuit
    return qc

# Length of key
n = 50

# generation of a random string of bits (only known to Alice)
alice_bits = randint(2, size=n*8)
print(f"Binary string generated by Alice: \n{alice_bits}\n")

# function to prepare each qubit in the corresponding basis
# all qubits are initialized to |0> in the Z-basis by Qiskit
# if bit = 0, transmit |0>. if bit = 1, transmit |+>
def prepare_qubits(bits):
    message = []
    for i in range(n*8):
        # generate a quantum circuit with 1 input qubit and 1 output bit to transform each qubit
        qc = QuantumCircuit(1, 1)
        if bits[i] == 0:
            pass        # qubit already initialized to |0>
        else:
            qc.h(0)     # transform |0> to |+>   
        qc.barrier()
        message.append(qc)
    
    return message

message = prepare_qubits(alice_bits)

# This message is then sent to Bob over the quantum communication channel

# generation of random basis for each qubit to measure (only known to Bob)
# 0 => measure in Z-basis, 1 => measure in the X-basis.
bob_bases = randint(2, size=n*8)
print(f" 0 => measure in Z-basis, 1 => measure in the X-basis. \n Basis used by Bob for each qubit: \n{bob_bases}\n")

# function to measure each qubit in the corresponding basis
def measure_qubits(message, bases):
    qasm_sim = Aer.get_backend('qasm_simulator')
    measurements = []
    measurements_z = []
    for i in range(n*8):
        # measuring in Z-basis
        if bases[i] == 0: 
            message[i].measure(0,0)
            # simulator
            qasm_sim = Aer.get_backend('qasm_simulator')
            q_obj = assemble(message[i], shots=1, memory=True)
            
            # run the experiment and measure state of qubit
            result = qasm_sim.run(q_obj).result()
            measured_bit = int(result.get_memory()[0])
            measurements_z.append(measured_bit)
            
            if measured_bit == 1:
                measurements.append(bases[i])
        
        # measuring in X-basis
        if bases[i] == 1: 
            message[i] = x_measurement(message[i], 0, 0)
            # simulator
            qasm_sim = Aer.get_backend('qasm_simulator')
            q_obj = assemble(message[i], shots=1, memory=True)
            
            # run the experiment and measure state of qubit
            result = qasm_sim.run(q_obj).result()
            measured_bit = int(result.get_memory()[0])
            measurements_z.append(measured_bit)
            
            if measured_bit == 1:
                measurements.append(bases[i])
            
                
    return measurements, message, measurements_z

# function to implement interception (measurement)
def eve_intercept(message):
    # Eve also needs to choose a random basis to measure each qubit
    eve_bases = randint(2, size=n*8)
    intercepted_measurements, message, temp = measure_qubits(message, eve_bases)
    for i in range(n*8):
        message[i].barrier()
    print(f"Output bits measured by Eve: \n{intercepted_measurements}\n")
    return message
 
if(intrusion):  
    # interception by Eve
    message = eve_intercept(message) 
    
# Bob measures incoming qubits
bob_results, message, Z = measure_qubits(message, bob_bases)

def discard_bits(alice_string, bob_z):
    alice_key = []
    for i in range(n*8):
        if bob_z[i] == 1:
            alice_key.append(alice_string[i])
    return alice_key
    
def invert_bits(string):
    for i in range(len(string)):
        if string[i] == 0:
            string[i] = 1
        else:
            string[i] = 0
    return string

bob_key = invert_bits(bob_results)
alice_key = discard_bits(alice_bits, Z)

print("BEFORE ERROR CORRECTION \n")
print(f"Length of Alice's key: {len(alice_key)}\n Alice's key : \n{alice_key}\n")
print(f"Length of Bob's key: {len(bob_key)}\n Bob's key : \n{bob_key}\n")

key_length = len(alice_key)

# ERROR CORRECTION / INTRUDER CHECK
def intruder_check(alice_key, bob_key):
    flag = 0
    i = random.randint(0, key_length)
    a = int(key_length/2)
    if i > a:
        final_alice_key = alice_key[i-a: i]
        final_bob_key = bob_key[i-a: i]
        if final_alice_key != final_bob_key:
            flag = 1
        else:
            final_alice_key = alice_key[:i-a] + alice_key[i+1:]
            final_bob_key = bob_key[:i-a]  + bob_key[i+1:]
    else:
        final_alice_key = alice_key[i:i+a]
        final_bob_key = bob_key[i:i+a]
        if final_alice_key != final_bob_key:
            flag = 1
        else:
            final_alice_key = alice_key[:i-a] + alice_key[i+1:]
            final_bob_key = bob_key[:i-a] + bob_key[i+1:]      
    return final_alice_key, final_bob_key, flag

alice_key, bob_key, flag = intruder_check(alice_key, bob_key)

print("AFTER ERROR CORRECTION \n")

if(flag == 0):
    print("Intruder is not present.\n")
    print(f"Length of Alice's key: {len(alice_key)}\n Alice's key : \n{alice_key}\n")
    print(f"Length of Bob's key: {len(bob_key)}\n Bob's key : \n{bob_key}\n")
else:
    print("Intruder has been detected.\n")
