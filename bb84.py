from qiskit import QuantumCircuit, Aer, assemble
from numpy.random import randint
import random

intrusion = input("Intrusion? (True / False) \n")
if intrusion == "True":
    intrusion = True
else:
    intrusion = False

# Qiskit measures in Z-basis by default

# function to measure in the X-basis
def x_measurement(qc, qubit, cbit):
    # Measure the "qubit" in X-basis and store the result in "cbit"
    # convert [|+> or |->] to [|0> or |1>] OR vice-versa
    qc.h(qubit)
    # measure this qubit in Z-basis
    qc.measure(qubit, cbit)
    # return the modified circuit
    return qc

# Length of Alice's initial message 
n = 100

# generation of a random string of bits (only known to Alice)
alice_bits = randint(2, size=n)
print(f"Binary string generated by Alice: \n{alice_bits}\n")


# generation of random basis for each qubit (only known to Alice)
# 0 => prepare in Z-basis, 1 => prepare in the X-basis.
alice_bases = randint(2, size=n)
print(f"Basis used by Alice for each qubit: \n{alice_bases}\n")

# function to prepare each qubit in the corresponding basis
# all qubits are initialized to |0> in the Z-basis by Qiskit
def prepare_qubits(bits, bases):
    message = []
    for i in range(n):
        # generate a quantum circuit with 1 input qubit and 1 output bit to transform each qubit
        qc = QuantumCircuit(1, 1)
        # prepare qubit in Z-basis
        if bases[i] == 0:
            if bits[i] == 0:
                pass        # since qubits are already initialized to 0
            else:
                qc.x(0)
        # prepare qubit is X-basis
        else:
            if bits[i] == 0:
                qc.h(0)     # transform |0> to |+>   
            else:
                qc.x(0)     # transform |0> to |1> 
                qc.h(0)     # transform |1> to |->
        qc.barrier()
        message.append(qc)
    
    return message

message = prepare_qubits(alice_bits, alice_bases)

# This message is then sent to Bob over the quantum communication channel

# generation of random basis for each qubit to measure (only known to Bob)
# 0 => measure in Z-basis, 1 => measure in the X-basis.
bob_bases = randint(2, size=n)
print(f"Basis used by Bob for each qubit: \n{bob_bases}\n")

# function to measure each qubit in the corresponding basis
def measure_qubits(message, bases):
    qasm_sim = Aer.get_backend('qasm_simulator')
    measurements = []
    for i in range(n):
        # measuring in Z-basis
        if bases[i] == 0: 
            message[i].measure(0,0)
        # measuring in X-basis
        if bases[i] == 1: 
            message[i] = x_measurement(message[i], 0, 0)
            
        # simulator
        qasm_sim = Aer.get_backend('qasm_simulator')
        q_obj = assemble(message[i], shots=1, memory=True)
        
        # run the experiment and measure state of qubit
        result = qasm_sim.run(q_obj).result()
        measured_bit = int(result.get_memory()[0])
        measurements.append(measured_bit)
        
    return measurements, message

# function to implement interception (measurement)
def eve_intercept(message):
    # Eve also needs to choose a random basis to measure each qubit
    eve_bases = randint(2, size=n)
    intercepted_measurements, message = measure_qubits(message, eve_bases)
    for i in range(n):
        message[i].barrier()
    print(f"Output bits measured by Eve: \n{intercepted_measurements}\n")
    return message
 
if(intrusion):  
    # interception by Eve
    message = eve_intercept(message) 
    
# Bob measures incoming qubits
bob_results, message = measure_qubits(message, bob_bases)
print(f"Output bits measured by Bob : \n{bob_results}\n")


# Alice and Bob reveal their choice of bases publicly
# if they used the same basis, bob will measure correctly
# if they used different basis, bob will have garbage value

# function to remove garbage values
def discard_bits(a_bases, b_bases, bits):
    key = []
    for i in range(n):
        if a_bases[i] == b_bases[i]:
            # If both used the same basis, append bit to key.
            key.append(bits[i])
            
    return key

# garbage removal
alice_key = discard_bits(alice_bases, bob_bases, alice_bits)
bob_key = discard_bits(alice_bases, bob_bases, bob_results)
key_length = len(alice_key)

print(f"Length of Key after discarding bits: {key_length}\n")
print(f"Alice's key after garbage removal: {alice_key}\n")
print(f"Bob's key after garbage removal: {bob_key}\n")

# ERROR DETECTION
# divide both keys into random blocks of length 1/10th of key length. 
# compute and compare parity of each block.
# parity check: even party => 0, odd parity => 1
# repeat process 100 times

count = 0
flag = 0

while(count < 100):
    i = random.randint(0, int(0.9*key_length))
    alice_sample = alice_key[i:i+int(0.1*key_length)]
    bob_sample = bob_key[i:i+int(0.1*key_length)]
    alice_parity = alice_sample.count(1) % 2
    bob_parity  = bob_sample.count(1) % 2
    if (alice_parity != bob_parity):
        flag = 1 
    count += 1

# check for intruder's presence.
# there are no errors introduced during simulation.
# errors can only be introduced by an intruder.
if(flag == 0):
    print("Intruder is not present.\n")
else:
    print("Intruder has been detected.\n")
 
